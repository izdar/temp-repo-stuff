// SSH RESPONSE-ONLY SPEC - Server behavior only (FIXED)
// Added s2c_banner to response enum

enum request {
  requestNotSet,
  c2s_kexinit,
  c2s_kexdh_init,
  c2s_kex_ecdh_init,
  c2s_newkeys_request,
  c2s_service_request_userauth,
  c2s_userauth_request,
  c2s_channel_open,
  c2s_channel_window_adjust,
  c2s_channel_data,
  c2s_channel_eof,
  c2s_channel_close,
  c2s_channel_request,
  c2s_global_request,
  c2s_disconnect,
  c2s_unimplemented,
  c2s_debug
};

enum response {
  responseNotSet,
  s2c_banner,                      // ← ADDED: SSH server banner "SSH-2.0-..."
  s2c_kexinit,
  s2c_kexdh_reply,
  s2c_kex_ecdh_reply,
  s2c_newkeys_response,
  s2c_service_accept_userauth,
  s2c_userauth_failure,
  s2c_userauth_success,
  s2c_userauth_banner,
  s2c_channel_open_confirmation,
  s2c_channel_open_failure,
  s2c_channel_window_adjust,
  s2c_channel_data,
  s2c_channel_eof,
  s2c_channel_close,
  s2c_channel_request_response,
  s2c_global_request_response,
  s2c_disconnect,
  s2c_unimplemented,
  s2c_debug
};

bool encrypted;
bool mac_ok;
bool hostkey_present;
bool sig_ok;

int  pkt_len;
int  pad_len;
int  chan_data_len;

int  auth_attempts;
bool is_auth_method_none;

bool report_violation;
int  violation_code;

/* ========== RESPONSE-ONLY PROPERTIES ==========
   All properties filter by: response != responseNotSet
   This ensures we only check server responses
*/

/* --------------------------
   0x – Server Banner (First Message)
   -------------------------- */

/* 0) Server banner should be the first message (optional rule) */
// H(response = s2c_banner -> !O(response != responseNotSet));

/* --------------------------
   1x – KEX / NEWKEYS Server Responses
   -------------------------- */

/* 1) Server NEWKEYS must be preceded by both KEXINITs */
H(
  response = s2c_newkeys_response ->
    ( O(request = c2s_kexinit) & O(response = s2c_kexinit) )
);

/* 2) KEX reply must include hostkey and valid signature */
H(
  (response = s2c_kexdh_reply | response = s2c_kex_ecdh_reply) ->
    ( hostkey_present = true & sig_ok = true )
);

/* 3) Server NEWKEYS must follow client KEX init */
H(
  response = s2c_newkeys_response ->
    O(request = c2s_kexdh_init | request = c2s_kex_ecdh_init)
);

/* --------------------------
   2x – Server Response Encryption (Post-NEWKEYS)
   -------------------------- */

/* 4) Server responses after NEWKEYS must be encrypted */
H(
  (response != responseNotSet & response != s2c_newkeys_response & 
   response != s2c_banner &
   O(response = s2c_newkeys_response) & O(request = c2s_newkeys_request)) ->
    ( encrypted = true )
);

/* 5) Server responses after NEWKEYS must have valid MAC */
H(
  (response != responseNotSet & response != s2c_newkeys_response &
   response != s2c_banner &
   O(response = s2c_newkeys_response) & O(request = c2s_newkeys_request)) ->
    ( mac_ok = true )
);

/* 6) Padding sanity on server responses (skip banner) */
H(
  (response != responseNotSet & response != s2c_banner & 
   pkt_len > 0 & pad_len >= 0) ->
    (pad_len >= 4 & pad_len < 256 & pkt_len > pad_len)
);

/* --------------------------
   3x – Authentication Responses
   -------------------------- */

/* 7) Service accept must follow service request */
H(
  response = s2c_service_accept_userauth ->
    O(request = c2s_service_request_userauth)
);

/* 8) Auth success must follow auth request */
H(
  response = s2c_userauth_success ->
    O(request = c2s_userauth_request)
);

/* 9) Auth success must be after NEWKEYS (both directions) */
H(
  response = s2c_userauth_success ->
    ( O(request = c2s_newkeys_request) & O(response = s2c_newkeys_response) )
);

/* 10) Auth success with zero attempts is suspicious (auth bypass) */
H(
  response = s2c_userauth_success ->
    ( auth_attempts > 0 )
);

/* 11) Auth success must not accept "none" method */
H(
  response = s2c_userauth_success ->
    ( is_auth_method_none = false )
);

/* 12) Server auth responses after NEWKEYS must be encrypted */
H(
  (response = s2c_userauth_failure | response = s2c_userauth_success) ->
    (
      ( O(request = c2s_newkeys_request) & O(response = s2c_newkeys_response) )
      -> encrypted = true
    )
);

/* --------------------------
   4x – Channel Responses
   -------------------------- */

/* 13) Channel open confirmation follows open request */
H(
  response = s2c_channel_open_confirmation ->
    O(request = c2s_channel_open)
);

/* 14) Channel open failure follows open request */
H(
  response = s2c_channel_open_failure ->
    O(request = c2s_channel_open)
);

/* 15) Server channel data requires established channel */
H(
  response = s2c_channel_data ->
    ( O(request = c2s_channel_open) & O(response = s2c_channel_open_confirmation) )
);

/* 16) Server should not send data after client closed channel */
H(
  response = s2c_channel_data ->
    !O(request = c2s_channel_close)
);

/* 17) Server window adjust requires established channel */
H(
  response = s2c_channel_window_adjust ->
    ( O(request = c2s_channel_open) & O(response = s2c_channel_open_confirmation) )
);

/* 18) Server channel data must have positive length */
H(
  response = s2c_channel_data ->
    ( chan_data_len > 0 )
);

/* --------------------------
   5x – Server Unimplemented & Global Responses
   -------------------------- */

/* 19) Server UNIMPLEMENTED must correspond to prior request */
H(
  response = s2c_unimplemented ->
    O(request = c2s_global_request | request = c2s_channel_request)
);

/* 20) Global request response must follow global request */
H(
  response = s2c_global_request_response ->
    O(request = c2s_global_request)
);

/* --------------------------
   6x – Server Disconnect Semantics
   -------------------------- */

/* 21) Server disconnect after NEWKEYS should follow some auth feedback */
H(
  (response = s2c_disconnect &
   O(response = s2c_newkeys_response)) ->
     O(response = s2c_userauth_failure |
       response = s2c_userauth_banner |
       response = s2c_userauth_success |
       response = s2c_service_accept_userauth)
);

/* 22) Repeated service-accept without intervening disconnect/rekey is suspicious */
H(
  response = s2c_service_accept_userauth ->
    !O(
      response = s2c_service_accept_userauth &
      !( request = c2s_disconnect |
         response = s2c_disconnect |
         request = c2s_newkeys_request |
         response = s2c_newkeys_response )
    )
);

/* --------------------------
   7x – MAC Validation (Critical Security)
   -------------------------- */

/* 23) After NEWKEYS, server responses must have valid MAC */
H(
  (response != responseNotSet & response != s2c_banner &
   O(request = c2s_newkeys_request) & O(response = s2c_newkeys_response)) ->
    ( mac_ok = true )
);

/* ========== REMOVED CLIENT-SIDE PROPERTIES ==========
   Original rule #16: Client channel data after close (client-side)
   Original rule #20: Client EOF requirements (client-side)
   
   These check client behavior, not server responses.
*/
